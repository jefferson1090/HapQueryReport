
const oracledb = require('oracledb');

class OracleAdapter {
    constructor(config) {
        this.config = config; // { user, password, connectString }
        this.pool = null;
        this.onMessageCallback = null;
        this.onPresenceCallback = null;
        this.userId = 'user_' + Math.floor(Math.random() * 100000);
        this.pollingInterval = null;
        this.heartbeatInterval = null;
        this.lastPollId = 0;
    }

    async connect() {
        console.log('[OracleAdapter] Connecting to ' + this.config.connectString);
        try {
            this.pool = await oracledb.createPool({
                user: this.config.user,
                password: this.config.password,
                connectString: this.config.connectString,
                poolMin: 1,
                poolMax: 4,
                poolIncrement: 1
            });

            await this.ensureSchema();

            // Start Polling (Messages + Presence)
            this.startPolling();
            this.startHeartbeat();

            return true;
        } catch (e) {
            console.error('[OracleAdapter] Connection failed:', e);
            return false;
        }
    }

    async ensureSchema() {
        let conn;
        try {
            conn = await this.pool.getConnection();

            // Check Tables
            const checkTable = async (tableName, ddl) => {
                try {
                    await conn.execute(`SELECT 1 FROM ${tableName} WHERE ROWNUM = 1`);
                } catch (e) {
                    if (e.message.includes('ORA-00942')) {
                        console.log(`[OracleAdapter] Creating table ${tableName}...`);
                        await conn.execute(ddl);
                        await conn.commit();
                    }
                }
            };

            await checkTable('HAP_CHAT_MESSAGES', `
                CREATE TABLE HAP_CHAT_MESSAGES (
                    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
                    SENDER VARCHAR2(100),
                    CONTENT CLOB,
                    MSG_TYPE VARCHAR2(50) DEFAULT 'TEXT',
                    RECIPIENT VARCHAR2(100) DEFAULT 'ALL',
                    METADATA CLOB,
                    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            `);

            await checkTable('HAP_CHAT_USERS', `
                CREATE TABLE HAP_CHAT_USERS (
                    USERNAME VARCHAR2(100) PRIMARY KEY,
                    TEAM VARCHAR2(100),
                    LAST_SEEN TIMESTAMP,
                    USER_ID VARCHAR2(100)
                )
            `);

        } catch (e) {
            console.error('[OracleAdapter] Schema Init Error:', e);
        } finally {
            if (conn) await conn.close();
        }
    }

    startPolling() {
        this.pollingInterval = setInterval(async () => {
            // Poll for Messages
            await this.pollMessages();
            // Poll for Online Users
            await this.pollPresence();
        }, 3000);
    }

    startHeartbeat() {
        this.heartbeatInterval = setInterval(async () => {
            await this.sendHeartbeat();
        }, 10000); // Pulse every 10s
    }

    async sendHeartbeat() {
        if (!this.pool || !this.currentUsername) return;
        let conn;
        try {
            conn = await this.pool.getConnection();
            // Upsert Logic (Merge)
            const sql = `
                MERGE INTO HAP_CHAT_USERS target
                USING (SELECT :1 AS username FROM dual) source
                ON (target.USERNAME = source.username)
                WHEN MATCHED THEN
                    UPDATE SET LAST_SEEN = CURRENT_TIMESTAMP, TEAM = :2, USER_ID = :3
                WHEN NOT MATCHED THEN
                    INSERT (USERNAME, TEAM, LAST_SEEN, USER_ID) 
                    VALUES (:1, :2, CURRENT_TIMESTAMP, :3)
            `;
            await conn.execute(sql, [this.currentUsername, this.currentTeam || 'Geral', this.userId], { autoCommit: true });
        } catch (e) {
            console.error('[OracleAdapter] Heartbeat fail:', e);
        } finally {
            if (conn) await conn.close();
        }
    }

    async pollMessages() {
        if (!this.pool || !this.onMessageCallback) return;
        let conn;
        try {
            conn = await this.pool.getConnection();
            // Get messages newer than ID (assuming auto-inc ID implies time order effectively enough for polling app)
            // Or use timestamp. Let's use ID for simplicity if we track lastPollId locally.
            // On first connect, maybe fetch last 50?

            let query = `SELECT ID, SENDER, CONTENT, MSG_TYPE, RECIPIENT, METADATA, CREATED_AT FROM HAP_CHAT_MESSAGES WHERE ID > :1 ORDER BY ID ASC`;

            // If it's the very first poll, verify where we start. 
            // Actually, simple logic: get max ID first time, then poll > max ID?
            // For now, let's just get messages > lastPollId. 
            // If lastPollId is 0, we might get ALL history. So we should limit.

            if (this.lastPollId === 0) {
                // First run: Get Max ID to start "now", or get recent 50 history?
                // The "ChatService" requests history separately. Here we just want *new* incoming realtime events.
                // So we should start from the checks.
                const res = await conn.execute('SELECT MAX(ID) as LAST_ID FROM HAP_CHAT_MESSAGES');
                this.lastPollId = res.rows[0].LAST_ID || 0;
                return;
            }

            const result = await conn.execute(query, [this.lastPollId]);

            if (result.rows && result.rows.length > 0) {
                for (const row of result.rows) {
                    // row: [ID, SENDER, CONTENT, TYPE, RECIP, META, TIME] (Array if not object mode)
                    // We need to check execution options. Default is Array.
                    // Let's assume default behavior check.

                    // To be safe, let's use outFormat: oracledb.OUT_FORMAT_OBJECT if possible, 
                    // but standard 'execute' returns array by default.

                    // Let's stick to array index mapping for simplicity or modify execute.
                }
            }

            // Re-run with Object Output
            const resultObj = await conn.execute(query, [this.lastPollId], { outFormat: oracledb.OUT_FORMAT_OBJECT });

            if (resultObj.rows && resultObj.rows.length > 0) {
                for (const row of resultObj.rows) {
                    this.lastPollId = row.ID;

                    // Notify Listener
                    let metadata = null;
                    if (row.METADATA) {
                        try {
                            // CLOB handling: if it's a huge CLOB, we might need manual read. 
                            // But usually fetchAsString takes care if configured?
                            // For small JSON, it returns string.
                            // However, oracledb by default returns stream for CLOB unless fetchInfo is set.
                            // Let's just assume string for now or use getData.
                            if (row.METADATA.getData) metadata = await row.METADATA.getData(); // If streaming
                            else metadata = row.METADATA;

                            if (typeof metadata === 'string') metadata = JSON.parse(metadata);
                        } catch (e) { }
                    }

                    // Content CLOB
                    let content = row.CONTENT;
                    // ... same CLOB logic check if necessary, assuming fetchAsString or string return for small content

                    const msg = {
                        id: row.ID,
                        sender: row.SENDER,
                        content: content,
                        type: row.MSG_TYPE,
                        recipient: row.RECIPIENT,
                        metadata: metadata,
                        timestamp: row.CREATED_AT
                    };

                    this.onMessageCallback(msg);
                }
            }

        } catch (e) {
            console.error('[OracleAdapter] Poll Messages Error:', e);
        } finally {
            if (conn) await conn.close();
        }
    }

    async pollPresence() {
        if (!this.pool || !this.onPresenceCallback) return;
        let conn;
        try {
            conn = await this.pool.getConnection();
            // Select users seen in last 30 seconds
            const result = await conn.execute(
                `SELECT USERNAME, TEAM, USER_ID, LAST_SEEN FROM HAP_CHAT_USERS WHERE LAST_SEEN > SYSTIMESTAMP - INTERVAL '30' SECOND`,
                [],
                { outFormat: oracledb.OUT_FORMAT_OBJECT }
            );

            const onlineUsers = result.rows.map(r => ({
                username: r.USERNAME,
                team: r.TEAM,
                user_id: r.USER_ID,
                online_at: r.LAST_SEEN
            }));

            this.onPresenceCallback(onlineUsers);
        } catch (e) {
            console.error('[OracleAdapter] Poll Presence Error:', e);
        } finally {
            if (conn) await conn.close();
        }
    }

    setMessageHandler(callback) {
        this.onMessageCallback = callback;
    }

    setPresenceHandler(callback) {
        this.onPresenceCallback = callback;
    }

    async trackPresence(username, team) {
        this.currentUsername = username;
        this.currentTeam = team;
        await this.sendHeartbeat(); // Immediate pulse
    }

    async sendMessage(messageObject) {
        if (!this.pool) throw new Error("Not connected");
        let conn;
        try {
            conn = await this.pool.getConnection();
            const sql = `
                INSERT INTO HAP_CHAT_MESSAGES (SENDER, CONTENT, MSG_TYPE, RECIPIENT, METADATA)
                VALUES (:1, :2, :3, :4, :5)
            `;
            const metaStr = messageObject.metadata ? JSON.stringify(messageObject.metadata) : null;

            await conn.execute(sql, [
                messageObject.sender,
                messageObject.content,
                messageObject.type || 'TEXT',
                messageObject.recipient || 'ALL',
                metaStr
            ], { autoCommit: true });

            return true;
        } catch (e) {
            console.error('[OracleAdapter] Send error:', e);
            throw e;
        } finally {
            if (conn) await conn.close();
        }
    }

    async getHistory(limit = 50) {
        if (!this.pool) return [];
        let conn;
        try {
            conn = await this.pool.getConnection();
            // Fetch CLOBs as Strings for simplicity
            oracledb.fetchAsString = [oracledb.CLOB];

            const result = await conn.execute(
                `SELECT * FROM (
                    SELECT ID, SENDER, CONTENT, MSG_TYPE, RECIPIENT, METADATA, CREATED_AT 
                    FROM HAP_CHAT_MESSAGES 
                    ORDER BY ID DESC
                ) WHERE ROWNUM <= :1`,
                [limit],
                { outFormat: oracledb.OUT_FORMAT_OBJECT }
            );

            return result.rows.reverse().map(row => {
                let meta = row.METADATA;
                try { if (typeof meta === 'string') meta = JSON.parse(meta); } catch (e) { }
                return {
                    id: row.ID,
                    sender: row.SENDER,
                    content: row.CONTENT,
                    type: row.MSG_TYPE,
                    recipient: row.RECIPIENT,
                    metadata: meta,
                    timestamp: row.CREATED_AT
                };
            });
        } catch (e) {
            console.error('[OracleAdapter] History error:', e);
            return [];
        } finally {
            if (conn) await conn.close();
        }
    }
}

module.exports = OracleAdapter;
